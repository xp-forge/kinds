<?php namespace lang\partial;

use lang\mirrors\TypeMirror;
use lang\ClassFormatException;
use lang\DynamicClassLoader;

module xp-forge/partial {
  private static $verbs= ['\\with\\', '\\is\\', '\\including\\'];

  /**
   * Initializes this module, registering class loader for compile-time
   * transformations based on the classes extending the base class
   * `lang.partial.Transformation`.
   */
  public function initialize() {
    $v5= PHP_VERSION < 7;
    class_alias($v5 ? 'lang\partial\AccessorsV5' : 'lang\partial\AccessorsV7', 'lang\partial\Accessors');
    class_alias($v5 ? 'lang\partial\InstanceCreationV5' : 'lang\partial\InstanceCreationV7', 'lang\partial\InstanceCreation');

    $loader= DynamicClassLoader::instanceFor(__CLASS__);
    spl_autoload_register(function($class) use($loader) {
      foreach (self::$verbs as $verb) {
        if ($p= strpos($class, $verb)) {
          $cl= \xp::$cll;
          $l= strlen($verb);
          \xp::$cll= 0;
          try {
            $mirror= new TypeMirror(substr($class, 0, $p));
            $transform= $mirror->resolve(substr($class, $p + $l));

            if ($transform->kind()->isTrait()) {
              class_alias(strtr($transform->name(), '.', '\\'), $class);
            } else {
              $p= strrpos($class, '\\');
              $body= $transform->constructor()->newInstance()->transform($mirror);
              $type= strtr($class, '\\', '.');
              $loader->setClassBytes($type, 'namespace '.substr($class, 0, $p).'; trait '.substr($class, $p + 1).' { '.$body.' }');
              $loader->loadClass0($type);
            }
            \xp::$cll= $cl;
          } catch (\Exception $e) {   // PHP 5.x
            \xp::$cll= $cl;
            throw $e;
          } catch (\Throwable $e) {   // PHP 7.x
            \xp::$cll= $cl;
            throw $e;
          }
          return true;
        }
      }
      return false;
    });
  }
}